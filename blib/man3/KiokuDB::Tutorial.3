.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.10)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "KiokuDB::Tutorial 3"
.TH KiokuDB::Tutorial 3 "2010-02-26" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
KiokuDB::Tutorial \- Getting started with KiokuDB
.SH "INSTALLATION"
.IX Header "INSTALLATION"
The easiest way to install KiokuDB and a number of backends is
Task::KiokuDB.
.PP
KiokuDB depends on Moose and a few other modules out of the box, but no
specific storage module.
.PP
KiokuDB is a frontend to several backends, much like \s-1DBI\s0 uses DBDs to
connect to actual databases.
.PP
For development and testing you can use the KiokuDB::Backend::Hash backend,
which is an in memory store, but for production KiokuDB::Backend::BDB or
KiokuDB::Backend::DBI are the recommended backends.
.PP
See below for instructions on getting KiokuDB::Backend::BDB installed.
.SH "CREATING A DIRECTORY"
.IX Header "CREATING A DIRECTORY"
A KiokuDB directory is the object that contains all the common functionality
regardless of the backend.
.PP
The simplest directory ready for use can be created like this:
.PP
.Vb 3
\&    my $dir = KiokuDB\->new(
\&        backend => KiokuDB::Backend::Hash\->new
\&    );
.Ve
.PP
We will revisit other more interesting backend configuration later in this
document, but for now this will do.
.PP
You can also use \s-1DSN\s0 strings to connect to the various backends:
.PP
.Vb 1
\&    KiokuDB\->connect("hash");
\&
\&    KiokuDB\->connect("dbi:SQLite:dbname=foo", create => 1);
\&
\&    KiokuDB\->connect("bdb:dir=foo", create => 1);
.Ve
.PP
Or use a configuration file
.PP
.Vb 2
\&    KiokuDB\->connect("/path/to/my_db.yml");
\&    KiokuDB\->connect("/path/to/dir");
.Ve
.PP
With a configuration file like this:
.PP
.Vb 4
\&    backend:
\&      class: KiokuDB::Backend::DBI
\&      dsn: dbi:SQLite:dbname=/tmp/test.db
\&      create: 1
.Ve
.SH "USING THE DBI BACKEND"
.IX Header "USING THE DBI BACKEND"
During this tutorial we will be using the \s-1DBI\s0 backend for two reasons. The
first is \s-1DBI\s0's ubiquity \- almost everyone has used and knows how to install
and use it. The second is the possibility of easily looking behind the scenes,
to more clearly demonstrate what KiokuDB is doing.
.PP
That said, the examples will work with all backends exactly the same.
.PP
The \f(CW$dir\fR variable used below is created like this:
.PP
.Vb 4
\&    my $dir = KiokuDB\->connect(
\&        "dbi:SQLite:dbname=kiokudb_tutorial.db",
\&        create => 1,
\&    );
.Ve
.PP
Note that if you are connecting with a username and password you must specify
these as named arguments:
.PP
.Vb 5
\&    my $dir = KiokuDB\->connect(
\&        $dsn,
\&        user     => $user,
\&        password => $password,
\&    );
.Ve
.SH "INSERTING OBJECTS"
.IX Header "INSERTING OBJECTS"
Let's start by defining a simple class using Moose:
.PP
.Vb 2
\&    package Person;
\&    use Moose;
\&
\&    has name => (
\&        isa => "Str",
\&        is  => "rw",
\&    );
.Ve
.PP
We can instantiate it:
.PP
.Vb 1
\&    my $obj = Person\->new( name => "Homer Simpson" );
.Ve
.PP
and insert the object to the database as follows:
.PP
.Vb 1
\&    my $scope = $dir\->new_scope;
\&
\&    my $homer_id = $dir\->store($obj);
.Ve
.PP
This is very trivial use of KiokuDB, but it illustrates a few important
things.
.PP
First, no schema is necessary. KiokuDB can use Moose to introspect your
object without needing to predefine anything like tables.
.PP
Second, every object in the database has an \s-1ID\s0. If you don't choose an \s-1ID\s0 for
an object, KiokuDB will assign a \s-1UUID\s0 instead. The \s-1ID\s0 is like a primary key
in a relational database. If you want to choose an \s-1ID\s0 for your object, you can
do something like:
.PP
.Vb 1
\&    $dir\->store( homer => $obj );
.Ve
.PP
and \f(CW$obj\fR's \s-1ID\s0 will be \f(CW\*(C`homer\*(C'\fR. If you don't provide an \s-1ID\s0 a \s-1UUID\s0 will be
assigned automatically.
.PP
Third, all KiokuDB operations need to be performed within a \fBscope\fR. The
scope does not apply to a simple example like the above, but becomes necessary
once weak references are used. We will look into that in more detail later.
.SH "LOADING OBJECTS"
.IX Header "LOADING OBJECTS"
So now that Homer has been inserted into the database, we can fetch him out of
there using the \s-1ID\s0 we got from \f(CW\*(C`store\*(C'\fR.
.PP
.Vb 1
\&    my $homer = $dir\->lookup($homer_id);
.Ve
.PP
Assuming that \f(CW$scope\fR and \f(CW$obj\fR are still in scope, \f(CW$homer\fR and \f(CW$obj\fR
will actually be the same reference:
.PP
.Vb 1
\&    refaddr($homer) == refaddr($obj)
.Ve
.PP
This is because KiokuDB tracks which objects are \*(L"live\*(R" in the
\&\fBlive object set\fR (KiokuDB::LiveObjects).
.PP
If \f(CW$obj\fR and \f(CW$scope\fR are no longer in scope you'd need to create a new
scope, and then fetch the object from the database again:
.PP
.Vb 1
\&    my $scope = $dir\->new_scope;
\&
\&    my $homer = $dir\->lookup($homer_id);
.Ve
.PP
In this case since the original instance of Homer is no longer live, but has
been garbage collected by Perl, KiokuDB will fetch it from the backend.
.SH "WHAT WAS STORED"
.IX Header "WHAT WAS STORED"
Let's peek into the database momentarily. Launch the \s-1SQL\s0 command line tool to
your database:
.PP
.Vb 4
\&    % sqlite3 kiokudb_tutorial.db
\&    SQLite version 3.4.0
\&    Enter ".help" for instructions
\&    sqlite>
.Ve
.PP
The database schema has two tables, \f(CW\*(C`entries\*(C'\fR and \f(CW\*(C`gin_index\*(C'\fR:
.PP
.Vb 2
\&    sqlite> .tables
\&    entries    gin_index
.Ve
.PP
\&\f(CW\*(C`gin_index\*(C'\fR is used for more complex queries, and we'll get back to it at the
end of the tutorial.
.PP
Let's have a closer look at \f(CW\*(C`entries\*(C'\fR:
.PP
.Vb 9
\&    sqlite> .schema entries
\&    CREATE TABLE entries (
\&      id varchar NOT NULL,
\&      data blob NOT NULL,
\&      class varchar,
\&      root boolean NOT NULL,
\&      tied char(1),
\&      PRIMARY KEY (id)
\&    );
.Ve
.PP
The main columns are \f(CW\*(C`id\*(C'\fR and \f(CW\*(C`data\*(C'\fR. In KiokuDB every object has an \s-1ID\s0
which serves as a primary key and a \s-1BLOB\s0 of data associated with it.
.PP
Since the default serializer for the \s-1DBI\s0 backend is
KiokuDB::Serializer::JSON, we can peek at the data.
.PP
First we'll set \f(CW\*(C`sqlite\*(C'\fR's output mode to \f(CW\*(C`line\*(C'\fR. This is easier to read with large columns:
.PP
.Vb 1
\&    sqlite> .mode line
.Ve
.PP
And select the data from the table:
.PP
.Vb 3
\&    sqlite> select id, data from entries;
\&       id = 201C5B55\-E759\-492F\-8F20\-A529C7C02C8B
\&     data = {"_\|_CLASS_\|_":"Person","data":{"name":"Homer Simpson"},"id":"201C5B55\-E759\-492F\-8F20\-A529C7C02C8B","root":true}
.Ve
.PP
As you can see the \f(CW\*(C`name\*(C'\fR attribute is stored under the \f(CW\*(C`data\*(C'\fR key inside the
blob, as is the object's class.
.PP
The \f(CW\*(C`data\*(C'\fR column contains all of the data necessary to recreate the object.
.PP
All the other columns are used solely for lookups. Later on we'll show how to
create more search columns.
.PP
When using KiokuDB::Backend::BDB the on-disk format is actually a hash of
\&\f(CW\*(C`id\*(C'\fR to \f(CW\*(C`data\*(C'\fR.
.SH "OBJECT RELATIONSHIPS"
.IX Header "OBJECT RELATIONSHIPS"
Let's extend the \f(CW\*(C`Person\*(C'\fR class to hold some more interesting data than just a
\&\f(CW\*(C`name\*(C'\fR:
.PP
.Vb 1
\&    package Person;
\&
\&    has spouse => (
\&        isa => "Person",
\&        is  => "rw",
\&        weak_ref => 1,
\&    );
.Ve
.PP
This new \f(CW\*(C`spouse\*(C'\fR attribute will hold a reference to another person object.
.PP
Let's first create and insert another object:
.PP
.Vb 3
\&    my $marge_id = $dir\->store(
\&        Person\->new( name => "Marge Simpson" ),
\&    );
.Ve
.PP
Now that we have both objects in the database, let's link them together:
.PP
.Vb 2
\&    {
\&        my $scope = $dir\->new_scope;
\&
\&        my ( $marge, $homer ) = $dir\->lookup( $marge_id, $homer_id );
\&
\&        $marge\->spouse($homer);
\&        $homer\->spouse($marge);
\&
\&        $dir\->store( $marge, $homer );
\&    }
.Ve
.PP
Now we have created a persistent \fBobject graph\fR, that is several objects which
point to each other.
.PP
The reason \f(CW\*(C`spouse\*(C'\fR had the \f(CW\*(C`weak_ref\*(C'\fR option was so that this circular
structure will not leak.
.PP
When then objects are updated in the database, KiokuDB sees that their
\&\f(CW\*(C`spouse\*(C'\fR attribute contains references, and this relationship will be encoded
using their unique \s-1ID\s0 in storage.
.PP
To load the graph, we can do something like this:
.PP
.Vb 2
\&    {
\&        my $scope = $dir\->new_scope;
\&
\&        my $homer = $dir\->lookup($homer_id);
\&
\&        print $homer\->spouse\->name; # Marge Simpson
\&    }
\&
\&    {
\&        my $scope = $dir\->new_scope;
\&
\&        my $marge = $dir\->lookup($marge_id);
\&
\&        print $marge\->spouse\->name; # Homer Simpson
\&
\&        refaddr($marge) == refaddr($marge\->spouse\->spouse); # true
\&    }
.Ve
.PP
When KiokuDB is loading the initial object, all the objects the object
depends on will also be loaded. The \f(CW\*(C`spouse\*(C'\fR attribute contains a
reference to another object (by \s-1ID\s0), and this link is resolved at inflation
time.
.ie n .SS "The purpose of ""new_scope"""
.el .SS "The purpose of \f(CWnew_scope\fP"
.IX Subsection "The purpose of new_scope"
This is where \f(CW\*(C`new_scope\*(C'\fR becomes important. As objects are inflated from the
database, they are pushed onto the live object scope, in order to increase
their reference count.
.PP
If this was not done, by the time \f(CW$homer\fR was returned from \f(CW\*(C`lookup\*(C'\fR his
\&\f(CW\*(C`spouse\*(C'\fR attribute would have been cleared because there is no other reference
to Marge.
.PP
If, on the other hand the circular structure was not weak, it would have to be
broken manually, which is very error prone.
.PP
By using this idiom:
.PP
.Vb 2
\&    {
\&        my $scope = $dir\->new_scope;
\&
\&        # do all KiokuDB work in here
\&    }
.Ve
.PP
You are ensuring that the objects live at least as long as is necessary.
.PP
In a web application context usually you create one new scope per request.
.PP
While scopes can nest, this is not a requirement.
.PP
You are free to create as many or as few scopes as you like, as long as there
is at least one, but note that child scopes refer to their parents to ensure
that all objects that were already live at the time that a scope is created are
still alive.
.SH "REFERENCES IN THE DATABASE"
.IX Header "REFERENCES IN THE DATABASE"
Now that we have an object graph in the database let's have another look at
what's inside.
.PP
.Vb 3
\&    sqlite> select id, data from entries;
\&       id = 201C5B55\-E759\-492F\-8F20\-A529C7C02C8B
\&     data = {"_\|_CLASS_\|_":"Person","data":{"name":"Homer Simpson","spouse":{"$ref":"05A8D61C\-6139\-4F51\-A748\-101010CC8B02.data"}},"id":"201C5B55\-E759\-492F\-8F20\-A529C7C02C8B","root":true}
\&
\&       id = 05A8D61C\-6139\-4F51\-A748\-101010CC8B02
\&     data = {"_\|_CLASS_\|_":"Person","data":{"name":"Marge Simpson","spouse":{"$ref":"201C5B55\-E759\-492F\-8F20\-A529C7C02C8B.data"}},"id":"05A8D61C\-6139\-4F51\-A748\-101010CC8B02","root":true}
.Ve
.PP
You'll notice the \f(CW\*(C`spouse\*(C'\fR field has a \s-1JSON\s0 object with a \f(CW$ref\fR field inside
it holding the \s-1UUID\s0 of the target object.
.PP
When data is loaded KiokuDB queues up references to unloaded objects and
then loads them in order to materialize the memory resident object graph.
.PP
If you're curious about why the data is represented this way, this format is
called \f(CW\*(C`JSPON\*(C'\fR, or JavaScript Persistent Object Notation
(<http://www.jspon.org/>). When using KiokuDB::Backend::Storable the
KiokuDB::Entry and KiokuDB::Reference objects are serialized with their
storable hooks instead.
.SH "OBJECT SETS"
.IX Header "OBJECT SETS"
More complex relationships (not necessarily 1 to 1) are fairly easy to model
with Set::Object.
.PP
Let's extend the \f(CW\*(C`Person\*(C'\fR class to add such a relationship:
.PP
.Vb 1
\&    package Person;
\&
\&    has children => (
\&        does => "KiokuDB::Set",
\&        is   => "rw",
\&    );
.Ve
.PP
KiokuDB::Set objects are KiokuDB specific wrappers for Set::Object.
.PP
.Vb 1
\&    my @kids = map { Person\->new( name => $_ ) } qw(maggie lisa bart);
\&
\&    use KiokuDB::Util qw(set);
\&
\&    my $set = set(@kids);
\&
\&    $homer\->children($set);
\&
\&    $dir\->store($homer);
.Ve
.PP
The \f(CW\*(C`set\*(C'\fR convenience function creates a new KiokuDB::Set::Transient
object. A transient set is one which started its life in memory space.
.PP
The \f(CW\*(C`weak_set\*(C'\fR convenience function also exists, creating a transient set with
Set::Object::Weak used internally to help avoid circular structures (for
instance if setting a \f(CW\*(C`parent\*(C'\fR attribute in our example).
.PP
The set object behaves pretty much like a normal Set::Object:
.PP
.Vb 1
\&    my @kids = $dir\->lookup($homer_id)\->children\->members;
.Ve
.PP
The main difference is that sets coming from the database are deferred by
default, that is the objects in \f(CW@kids\fR are not loaded until they are actually
needed.
.PP
This allows large object graphs to exist in the database, while only being
partially loaded, without breaking the encapsulation of user objects. This
behavior is implemented in KiokuDB::Set::Deferred and
KiokuDB::Set::Loaded.
.PP
This set object is optimized to make most operations defer loading. For
instance, if you intersect two deferred sets, only the members of the
intersection set will need to be loaded.
.SH "THE TYPEMAP"
.IX Header "THE TYPEMAP"
Storing an object with KiokuDB involves passing it to KiokuDB::Collapser,
the object that \*(L"flattens\*(R" objects into KiokuDB::Entry before the entries
are inserted into the backend.
.PP
The collapser uses a KiokuDB::TypeMap object that tells it how objects of
each type should be collapsed.
.PP
During retrieval of objects the same typemap is used to reinflate objects back
into working objects.
.PP
Trying to store an object that is not in the typemap is an error. The reason
behind this is that many objects depend on runtime states (for instance \f(CW\*(C`DBI\*(C'\fR
handles need a socket, objects based on \s-1XS\s0 modules have an internal pointer as
an integer), and even though the majority of objects are safe to serialize,
even a small bit of unreported fragility is usually enough to create large,
hard to debug problems.
.PP
An exception to this rule is Moose based objects, because they have
sufficient meta information available through Moose's powerful reflection
support in order to be safely serialized.
.PP
Additionally, the standard backends provide a default typemap for common
objects (DateTime, Path::Class, etc), which by default is merged with any
custom typemap you pass to KiokuDB.
.PP
So, in order to actually get KiokuDB to store things like Class::Accessor
based objects, you can do something like this:
.PP
.Vb 8
\&    my $dir = KiokuDB\->new(
\&        backend => $backend,
\&        typemap => KiokuDB::TypeMap\->new(
\&            entries => {
\&                "My::Object" => KiokuDB::TypeMap::Entry::Naive\->new,
\&            },
\&        ),
\&    );
.Ve
.PP
KiokuDB::TypeMap::Entry::Naive is a type map entry that performs naive
collapsing of the object, by simply walking it recursively.
.PP
When the collapser encounters an object it will ask
KiokuDB::TypeMap::Resolver for a collapsing routine based on the class of
the object.
.PP
This lookup is typically performed by \f(CW\*(C`ref $object\*(C'\fR, not using inheritance,
because a typemap entry that is safe to use with a superclass isn't necessarily
safe to use with a subclass. If you \fBdo\fR want inherited entries, specify
\&\f(CW\*(C`isa_entries\*(C'\fR:
.PP
.Vb 5
\&    KiokuDB::TypeMap\->new(
\&        isa_entries => {
\&            "My::Object" => KiokuDB::TypeMap::Entry::Naive\->new,
\&        },
\&    );
.Ve
.PP
If no normal (\f(CW\*(C`ref\*(C'\fR keyed) entry is found for an object, the isa entries are
searched for a superclass of that object. Subclass entries are tried before
superclass entries. The result of this lookup is cached, so it only happens
once per class.
.SS "Typemap Entries"
.IX Subsection "Typemap Entries"
If you want to do custom serialization hooks, you can specify hooks to collapse
your object:
.PP
.Vb 3
\&    KiokuDB::TypeMap::Entry::Callback\->new(
\&        collapse => sub {
\&            my $object = shift;
\&
\&            ...
\&
\&            return @some_args;
\&        },
\&        expand => sub {
\&            my ( $class, @some_args ) = @_;
\&
\&            ...
\&
\&            return $object;
\&        },
\&    );
.Ve
.PP
These hooks are called as methods on the object to be collapsed.
.PP
For instance the Path::Class related typemap \s-1ISA\s0 entry is:
.PP
.Vb 5
\&    \*(AqPath::Class::Entity\*(Aq => KiokuDB::TypeMap::Entry::Callback\->new(
\&        intrinsic => 1,
\&        collapse  => "stringify",
\&        expand    => "new",
\&    );
.Ve
.PP
The \f(CW\*(C`intrinsic\*(C'\fR flag is discussed in the next section.
.PP
Another option for typemap entries is KiokuDB::TypeMap::Entry::Passthrough,
which is appropriate when you know the backend's serialization can handle that
data type natively.
.PP
For example, if your object has a Storable hook which you know is
appropriate (e.g. contains no sub objects that need to be collapsible) and your
backend uses KiokuDB::Backend::Serialize::Storable. DateTime is an
example of a class with such storable hopes:
.PP
.Vb 1
\&    \*(AqDateTime\*(Aq => KiokuDB::Backend::Entry::Passthrough\->new( intrinsic => 1 )
.Ve
.SS "Intrinsic vs. First Class"
.IX Subsection "Intrinsic vs. First Class"
In KiokuDB every object is normally assigned an \s-1ID\s0, and if the object is
shared by several objects this relationship will be preserved.
.PP
However, for some objects this is not the desired behavior. These are objects
that represent values, like DateTime, Path::Class entries, \s-1URI\s0
objects, etc.
.PP
KiokuDB can be asked to collapse such objects \fBintrinsicly\fR, that is
instead of creating a new KiokuDB::Entry with its own \s-1ID\s0 for the object, the
object gets collapsed directly into its parent's structures.
.PP
This means that shared references that are collapsed intrinsically will be
loaded back from the database as two distinct copies, so updates to one will
not affect the other.
.PP
For instance, when we run the following code:
.PP
.Vb 1
\&    use Path::Class;
\&
\&    my $path = file(qw(path to foo));
\&
\&    $obj_1\->file($path);
\&
\&    $obj_2\->file($path);
\&
\&    $dir\->store( $obj_1, $obj_2 );
.Ve
.PP
While the following is true when the data is being inserted, it will no longer
be true when \f(CW$obj_1\fR and \f(CW$obj_2\fR are loaded from the database:
.PP
.Vb 1
\&    refaddr($obj_1\->file) == refaddr($obj_2\->file)
.Ve
.PP
This is because both \f(CW$obj_1\fR and \f(CW$obj_2\fR each got its own copy of \f(CW$path\fR.
.PP
This behavior is usually more appropriate for objects that aren't mutated, but
are instead cloned and replaced, and for which creating a first class entry in
the backend with its own \s-1ID\s0 is undesired.
.SS "The Default Typemap"
.IX Subsection "The Default Typemap"
Each backend comes with a default typemap, with some built in entries for
common \s-1CPAN\s0 modules' objects. KiokuDB::TypeMap::Default contains more
details.
.SH "SIMPLE SEARCHES"
.IX Header "SIMPLE SEARCHES"
Most backends support an inefficient but convenient simple search, which scans
the entries and matches fields.
.PP
If you want to make use of this \s-1API\s0 we suggest using KiokuDB::Backend::DBI
since simple searching is implemented using an \s-1SQL\s0 where clause, which is much
more efficient (you do have to set up the column manually though).
.PP
Calling the \f(CW\*(C`search\*(C'\fR method with a hash reference as the only argument invokes
the simple search functionality, returning a Data::Stream::Bulk with the
results:
.PP
.Vb 1
\&    my $stream = $dir\->search({ name => "Homer Simpson" });
\&
\&    while ( my $block = $stream\->next ) {
\&        foreach my $object ( @$block ) {
\&            # $object\->name eq "Homer Simpson"
\&       }
\&    }
.Ve
.PP
This exact \s-1API\s0 is intentionally still underdefined. In the future it will be
compatible with DBIx::Class 0.09's syntax.
.SS "\s-1DBI\s0 \s-1SEARCH\s0 \s-1COLUMNS\s0"
.IX Subsection "DBI SEARCH COLUMNS"
In order to make use of the simple search \s-1API\s0 we need to configure columns for
our \s-1DBI\s0 backend.
.PP
Let's create a 'name' column to search by:
.PP
.Vb 5
\&    my $dir = KiokuDB\->connect(
\&        "dbi:SQLite:dbname=foo",
\&        columns => [
\&            # specify extra columns for the \*(Aqentries\*(Aq table
\&            # in the same format you pass to DBIC\*(Aqs add_columns
\&
\&            name => {
\&                data_type => "varchar",
\&                is_nullable => 1, # probably important
\&            },
\&        ],
\&    );
.Ve
.PP
You can either alter the schema manually, or use \f(CW\*(C`kioku dump\*(C'\fR to back up your
data, delete the database, connect with \f(CW\*(C`create => 1\*(C'\fR and then use
\&\f(CW\*(C`kioku load\*(C'\fR.
.PP
To populate this column we'll need to load Homer and update him:
.PP
.Vb 4
\&    {
\&        my $s = $dir\->new_scope;
\&        $dir\->update( $dir\->lookup( $homer_id ) );
\&    }
.Ve
.PP
And this is what it looks in the database:
.PP
.Vb 2
\&       id = 201C5B55\-E759\-492F\-8F20\-A529C7C02C8B
\&     name = Homer Simpson
.Ve
.SH "GETTING STARTED WITH BDB"
.IX Header "GETTING STARTED WITH BDB"
The most mature backend for KiokuDB is KiokuDB::Backend::BDB. It performs
very well, and supports many features, like Search::GIN integration to
provide customized indexing of your objects and transactions.
.PP
KiokuDB::Backend::DBI is newer and not as tested, but also supports
transactions and Search::GIN based queries. It performs quite well too, but
isn't as fast as KiokuDB::Backend::BDB.
.SS "Installing KiokuDB::Backend::BDB"
.IX Subsection "Installing KiokuDB::Backend::BDB"
KiokuDB::Backend::BDB needs the BerkeleyDB module, and a recent version
of Berkeley \s-1DB\s0 itself, which can be found here:
<http://www.oracle.com/technology/software/products/berkeley\-db/db/index.html>.
.PP
BerkeleyDB (the library) normally installs into \f(CW\*(C`/usr/local/BerkeleyDB.4.7\*(C'\fR,
while BerkeleyDB (the module) looks for it in \f(CW\*(C`/usr/local/BerkeleyDB\*(C'\fR, so
adding a symbolic link should make installation easy.
.PP
Once you have BerkeleyDB installed, KiokuDB::Backend::BDB should install
without problem and you can use it with KiokuDB.
.SS "Using KiokuDB::Backend::BDB"
.IX Subsection "Using KiokuDB::Backend::BDB"
To use the \s-1BDB\s0 backend we must first create the storage. To do this the
\&\f(CW\*(C`create\*(C'\fR flag must be passed:
.PP
.Vb 6
\&    my $backend = KiokuDB::Backend::BDB\->new(
\&        manager => {
\&            home   => Path::Class::Dir\->new(qw(path to storage)),
\&            create => 1,
\&        },
\&    );
.Ve
.PP
The \s-1BDB\s0 backend uses BerkeleyDB::Manager to do a lot of the BerkeleyDB
gruntwork. The BerkeleyDB::Manager object will be instantiated using the
arguments provided in the \f(CW\*(C`manager\*(C'\fR attribute.
.PP
Now that the storage is created we can make use of this backend, much like before:
.PP
.Vb 1
\&    my $dir = KiokuDB\->new( backend => $backend );
.Ve
.PP
Subsequent opens will not require the \f(CW\*(C`create\*(C'\fR argument to be true, but it
doesn't hurt.
.PP
This \f(CW\*(C`connect\*(C'\fR call is equivalent to the above:
.PP
.Vb 1
\&    my $dir = KiokuDB\->connect( "bdb:dir=path/to/storage", create => 1 );
.Ve
.SH "TRANSACTIONS"
.IX Header "TRANSACTIONS"
Some backends (ones which do the KiokuDB::Backend::Role::TXN role) can be used
with transactions.
.PP
If you are familiar with DBIx::Class this should be very familiar:
.PP
.Vb 3
\&    $dir\->txn_do(sub {
\&        $dir\->store($obj);
\&    });
.Ve
.PP
This will create a BerkeleyDB level transaction, and all changes to the
database are committed if the block was executed cleanly.
.PP
If any error occurred the transaction will be rolled back, and the changes will
not be visible to subsequent reads.
.PP
Note that KiokuDB does \fBnot\fR touch live instances, so if you do something
like
.PP
.Vb 2
\&    $dir\->txn_do(sub {
\&        my $scope = $dir\->new_scope;
\&
\&        $obj\->name("Dancing Hippy");
\&        $dir\->store($obj);
\&
\&        die "an error";
\&    });
.Ve
.PP
the \f(CW\*(C`name\*(C'\fR attribute is \fBnot\fR rolled back, it is simply the \f(CW\*(C`store\*(C'\fR
operation that gets reverted.
.PP
Transactions will nest properly, and with most backends they generally increase
write performance as well.
.SH "QUERIES"
.IX Header "QUERIES"
KiokuDB::Backend::BDB::GIN is a subclass of KiokuDB::Backend::BDB that
provides Search::GIN integration.
.PP
Search::GIN is a framework to index and query objects, inspired by Postgres'
internal \s-1GIN\s0 api. \s-1GIN\s0 stands for Generalized Inverted Indexes.
.PP
Using Search::GIN arbitrary search keys can be indexed for your objects, and
these objects can then be looked up using queries.
.PP
For instance, one of the pre canned searches Search::GIN supports out of the
box is class indexing. Let's use Search::GIN::Extract::Callback to do custom
indexing of our objects:
.PP
.Vb 5
\&    my $dir = KiokuDB\->new(
\&        backend => KiokuDB::Backend::BDB::GIN\->new(
\&            extract => Search::GIN::Extract::Callback\->new(
\&                extract => sub {
\&                    my ( $obj, $extractor, @args ) = @_;
\&
\&                    if ( $obj\->isa("Person") ) {
\&                        return {
\&                            type => "user",
\&                            name => $obj\->name,
\&                        };
\&                    }
\&
\&                    return;
\&                },
\&            ),
\&        ),
\&    );
\&
\&    $dir\->store( @random_objects );
.Ve
.PP
To look up the objects, we use the a manual key lookup query:
.PP
.Vb 5
\&    my $query = Search::GIN::Query::Manual\->new(
\&        values => {
\&            type => "person",
\&        },
\&    );
\&
\&    my $stream = $dir\->search($query);
.Ve
.PP
The result is Data::Stream::Bulk object that represents the search results.
It can be iterated as follows:
.PP
.Vb 5
\&    while ( my $block = $stream\->next ) {
\&        foreach my $person ( @$block ) {
\&            print "found a person: ", $person\->name;
\&        }
\&    }
.Ve
.PP
Or even more simply, if you don't mind loading the whole resultset into memory:
.PP
.Vb 1
\&    my @people = $stream\->all;
.Ve
.PP
Search::GIN is very much in its infancy, and is very under documented.
However it does work for simple searches such as this and contains pre canned
solutions like Search::GIN::Extract::Class.
.PP
In short, it works today, but watch this space for new developments.
