.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.10)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "KiokuDB 3"
.TH KiokuDB 3 "2010-03-21" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
KiokuDB \- Object Graph storage engine
.SH "TUTORIAL"
.IX Header "TUTORIAL"
If you're new to KiokuDB check out KiokuDB::Tutorial.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use KiokuDB;
\&
\&    # use a DSN
\&    my $d = KiokuDB\->connect( $dsn, %args );
\&
\&    # or manually instantiate a backend
\&    my $d = KiokuDB\->new(
\&        backend => KiokuDB::Backend::Files\->new(
\&            dir        => "/tmp/foo",
\&            serializer => "yaml",
\&        ),
\&    );
\&
\&
\&    # create a scope object
\&    my $s = $d\->new_scope;
\&
\&
\&    # takes a snapshot of $some_object
\&    my $uuid = $d\->store($some_object);
\&
\&    # or with a custom ID:
\&    $d\->store( $id => $some_object ); # $id can be any string
\&
\&
\&    # retrieve by ID
\&    my $some_object = $d\->lookup($uuid);
\&
\&
\&
\&    # some backends (like DBI) support simple searchs
\&    $d\->search({ name => "foo" });
\&
\&
\&    # others use GIN queries (DBI supports both)
\&    $d\->search($gin_query);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
KiokuDB is a Moose based frontend to various data stores, somewhere in
between Tangram and Pixie.
.PP
Its purpose is to provide persistence for \*(L"regular\*(R" objects with as little
effort as possible, without sacrificing control over how persistence is
actually done, especially for harder to serialize objects.
.PP
KiokuDB is also non-invasive: it does not use ties, \f(CW\*(C`AUTOLOAD\*(C'\fR, proxy
objects, \f(CW\*(C`sv_magic\*(C'\fR or any other type of trickery.
.PP
Many features important for proper Perl space semantics are supported,
including shared data, circular structures, weak references, tied structures,
etc.
.PP
KiokuDB is meant to solve two related persistence problems:
.IP "Transparent persistence" 4
.IX Item "Transparent persistence"
Store arbitrary objects without changing their class definitions or worrying
about schema details, and without needing to conform to the limitations of
a relational model.
.IP "Interoperability" 4
.IX Item "Interoperability"
Persisting arbitrary objects in a way that is compatible with existing
data/code (for example interoprating with another app using CouchDB with \s-1JSPON\s0
semantics).
.SH "FUNDAMENTAL CONCEPTS"
.IX Header "FUNDAMENTAL CONCEPTS"
In order to use any persistence framework it is important to understand what it
does and how it does it.
.PP
Systems like Tangram or DBIx::Class generally require explicit meta data
and use a schema, which makes them fairly predictable.
.PP
When using transparent systems like KiokuDB or Pixie it is more important
to understand what's going on behind the scenes in order to avoid surprises and
limitations.
.PP
An architectural overview is available on the website:
<http://www.iinteractive.com/kiokudb/arch.html>
.PP
The process is explained here and in the various component documentation in
more detail.
.SS "Collapsing"
.IX Subsection "Collapsing"
When an object is stored using KiokuDB it's collapsed into an
KiokDB::Entry.
.PP
An entry is a simplified representation of the object, allowing the data to be
saved in formats as simple as \s-1JSON\s0.
.PP
References to other objects are converted to symbolic references in the entry,
so objects can be saved independently of each other.
.PP
The entries are given to the KiokuDB::Backend for actual storage.
.PP
Collapsing is explained in detail in KiokuDB::Collapser. The way an entry is
created varies with the object's class.
.SS "Linking"
.IX Subsection "Linking"
When objects are loaded, entries are retrieved from the backend using their
UIDs.
.PP
When a \s-1UID\s0 is already loaded (in the live object set of a KiokuDB instance,
see KiokuDB::LiveObjects) the live object is used. This way references to
shared objects are shared in memory regardless of the order the objects were
stored or loaded.
.PP
This process is explained in detail in KiokuDB::Linker.
.SH "ROOT SET MEMBERSHIP"
.IX Header "ROOT SET MEMBERSHIP"
Any object that is passed to \f(CW\*(C`store\*(C'\fR or \f(CW\*(C`insert\*(C'\fR directly is implicitly
considered a member of the root set.
.PP
This flag implies that the object is an identified resource and should not be
garbage collected with any of the proposed garbage collection schemes.
.PP
The root flag may be modified explicitly:
.PP
.Vb 1
\&    $kiokudb\->set_root(@objects); # or unset_root
\&
\&    $kiokudb\->update(@objects);
.Ve
.PP
Lastly, root set membership may also be specified explicitly by the typemap.
.PP
A root set member must be explicitly removed using \f(CW\*(C`delete\*(C'\fR or by
removing it from the root set. Only non-members of the root set will be
purged with any garbage collection scheme.
.SH "TRANSACTIONS"
.IX Header "TRANSACTIONS"
On supporting backends the \f(CW\*(C`txn_do\*(C'\fR method will execute a block and commit the
transaction at its end.
.PP
Nesting of \f(CW\*(C`txn_do\*(C'\fR blocks is always supported, though rolling back a nested
transaction may produce different results on different backends.
.PP
If the backend does not support transactions \f(CW\*(C`txn_do\*(C'\fR simply executes the code
block normally.
.SH "CONCURRENCY"
.IX Header "CONCURRENCY"
Most transactional backends are also concurrent.
.PP
KiokuDB::Backend::BDB and KiokuDB::Backend::CouchDB default to
serializable transaction isolation and do not suffer from deadlocks, but
serialization errors may occur, aborting the transaction (in which case the
transaction should be tried again).
.PP
KiokuDB::Backend::Files provides good concurrency support but will only
detect deadlocks on platforms which return \f(CW\*(C`EDEADLK\*(C'\fR from \f(CW\*(C`flock\*(C'\fR.
Directory::Transactional may provide alternative mechanisms in the future.
.PP
Concurrency support in KiokuDB::Backend::DBI depends on the database. SQLite
defaults to serializable transaction isolation out of the box, wheras MySQL and
PostgreSQL default to read committed.
.PP
Depending on your application read committed isolation may be sufficient, but
due to the graph structure nature of the data repeatable reads or serializable
level isolation is highly reccomended. Read committed isolation generally works
well when each row in the database is more or less independent of others, and
various constraints ensure integrity. Unfortunately this is not the case with
the graph layout.
.PP
To enable stronger isolation guarantees see
\&\*(L"Transactions\*(R" in KiokuDB::Backend::DBI for per-database pointers.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
KiokuDB uses a number of delegates which do the actual work.
.PP
Of these only \f(CW\*(C`backend\*(C'\fR is required, the rest have default definitions.
.PP
Additional attributes that are not commonly used are listed in \*(L"\s-1INTERNAL\s0
\&\s-1ATTRIBUTES\s0\*(R".
.IP "backend" 4
.IX Item "backend"
This attribute is required.
.Sp
This must be an object that does KiokuDB::Backend.
.Sp
The backend handles storage and retrieval of entries.
.IP "typemap" 4
.IX Item "typemap"
This is an instance KiokuDB::TypeMap.
.Sp
The typemap contains entries which control how KiokuDB::Collapser and
KiokuDB::Linker handle different types of objects.
.IP "allow_classes" 4
.IX Item "allow_classes"
An array references of extra classes to allow.
.Sp
Objects blessed into these classes will be collapsed using
KiokuDB::TypeMap::Entry:Naive.
.IP "allow_bases" 4
.IX Item "allow_bases"
An array references of extra base classes to allow.
.Sp
Objects derived from these classes will be collapsed using
KiokuDB::TypeMap::Entry:Naive.
.IP "allow_class_builders" 4
.IX Item "allow_class_builders"
If true adds KiokuDB::TypeMap::ClassBuilders to the merged typemap.
.Sp
It's possible to provide a hash reference of options to give to
\&\*(L"new\*(R" in KiokuDB::TypeMap::ClassBuilders.
.IP "check_class_versions" 4
.IX Item "check_class_versions"
Controls whether or not the class versions of objects are checked on load.
.Sp
Defaults to true.
.IP "class_version_table" 4
.IX Item "class_version_table"
A table of classes and versions that is passed to the default typemap entry for
Moose/Class::MOP objects.
.Sp
When a class version has changed between the time that an object was stored and
the time it's being retrieved, the data must be converted.
.Sp
See KiokuDB::TypeMap::Entry::MOP for more details.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "connect $dsn, %args" 4
.el .IP "connect \f(CW$dsn\fR, \f(CW%args\fR" 4
.IX Item "connect $dsn, %args"
\&\s-1DWIM\s0 wrapper for \f(CW\*(C`new\*(C'\fR.
.Sp
\&\f(CW$dsn\fR represents some sort of backend (much like \s-1DBI\s0 dsns map to DBDs).
.Sp
An example \s-1DSN\s0 is:
.Sp
.Vb 1
\&    my $dir = KiokuDB\->connect("bdb:dir=path/to/data/");
.Ve
.Sp
The backend moniker name is extracted by splitting on the colon. The rest of
the string is passed to \f(CW\*(C`new_from_dsn\*(C'\fR, which is documented in more detail in
KiokuDB::Backend.
.Sp
Typically \s-1DSN\s0 arguments are separated by \f(CW\*(C`;\*(C'\fR, with \f(CW\*(C`=\*(C'\fR separating keys and
values. Arguments with no value are assumed to denote boolean truth (e.g.
\&\f(CW\*(C`jspon:dir=foo;pretty\*(C'\fR means \f(CW\*(C`dir => "foo", pretty => 1\*(C'\fR). However, a
backend may override the default parsing, so this is not guaranteed.
.Sp
Extra arguments are passed both to the backend constructor, and the \f(CW\*(C`KiokuDB\*(C'\fR
constructor.
.Sp
Note that if you need a typemap you still need to pass it in:
.Sp
.Vb 1
\&    KiokuDB\->connect( $dsn, typemap => $typemap );
.Ve
.Sp
The \s-1DSN\s0 can also be a valid \s-1JSON\s0 string taking one of the following forms:
.Sp
.Vb 1
\&    dsn => \*(Aq["dbi:SQLite:foo",{"schema":"MyApp::DB"}]\*(Aq
\&
\&    dsn => \*(Aq{"dsn":"dbi:SQLite:foo","schema":"MyApp::DB"}\*(Aq
.Ve
.Sp
This allows more complicated arguments to be specified accurately, or arbitrary
options to be specified when the backend has nonstandard \s-1DSN\s0 parsing (for
instance KiokuDB::Backend::DBI simply passes the string to \s-1DBI\s0, so this
is necessary in order to specify options on the command line).
.ie n .IP "configure $config_file, %args" 4
.el .IP "configure \f(CW$config_file\fR, \f(CW%args\fR" 4
.IX Item "configure $config_file, %args"
\&\s-1TODO\s0
.ie n .IP "new %args" 4
.el .IP "new \f(CW%args\fR" 4
.IX Item "new %args"
Creates a new directory object.
.Sp
See \*(L"\s-1ATTRIBUTES\s0\*(R"
.IP "new_scope" 4
.IX Item "new_scope"
Creates a new object scope. Handled by \f(CW\*(C`live_objects\*(C'\fR.
.Sp
The object scope artificially bumps up the reference count of objects to ensure
that they live at least as long as the scope does.
.Sp
This ensures that weak references aren't deleted prematurely, and the object
graph doesn't get corrupted without needing to create circular structures and
cleaning up leaks manually.
.ie n .IP "lookup @ids" 4
.el .IP "lookup \f(CW@ids\fR" 4
.IX Item "lookup @ids"
Fetches the objects for the specified IDs from the live object set or from
storage.
.ie n .IP "store @objects" 4
.el .IP "store \f(CW@objects\fR" 4
.IX Item "store @objects"
.PD 0
.ie n .IP "store %objects" 4
.el .IP "store \f(CW%objects\fR" 4
.IX Item "store %objects"
.ie n .IP "store_nonroot @objects" 4
.el .IP "store_nonroot \f(CW@objects\fR" 4
.IX Item "store_nonroot @objects"
.ie n .IP "store_nonroot %objects" 4
.el .IP "store_nonroot \f(CW%objects\fR" 4
.IX Item "store_nonroot %objects"
.PD
Recursively collapses \f(CW@objects\fR and inserts or updates the entries.
.Sp
This performs a full update of every reachable object from \f(CW@objects\fR,
snapshotting everything.
.Sp
Strings found in the object list are assumed to be IDs for the following objects.
.Sp
The \f(CW\*(C`nonroot\*(C'\fR variant will not mark the objects as members of the root set
(therefore they will be subject to garbage collection).
.ie n .IP "update @objects" 4
.el .IP "update \f(CW@objects\fR" 4
.IX Item "update @objects"
Performs a shallow update of \f(CW@objects\fR (referants are not updated).
.Sp
It is an error to update an object not in the database.
.ie n .IP "deep_update @objects" 4
.el .IP "deep_update \f(CW@objects\fR" 4
.IX Item "deep_update @objects"
Update \f(CW@objects\fR and all of the objects they reference. All references
objects must already be in the database.
.ie n .IP "insert @objects" 4
.el .IP "insert \f(CW@objects\fR" 4
.IX Item "insert @objects"
.PD 0
.ie n .IP "insert %objects" 4
.el .IP "insert \f(CW%objects\fR" 4
.IX Item "insert %objects"
.ie n .IP "insert_nonroot @objects" 4
.el .IP "insert_nonroot \f(CW@objects\fR" 4
.IX Item "insert_nonroot @objects"
.ie n .IP "insert_nonroot %objects" 4
.el .IP "insert_nonroot \f(CW%objects\fR" 4
.IX Item "insert_nonroot %objects"
.PD
Inserts objects to the database.
.Sp
It is an error to insert objects that are already in the database, all elements
of \f(CW@objects\fR must be new, but their referants don't have to be.
.Sp
\&\f(CW@objects\fR will be collapsed recursively, but the collapsing stops at known
objects, which will not be updated.
.Sp
The \f(CW\*(C`nonroot\*(C'\fR variant will not mark the objects as members of the root set
(therefore they will be subject to garbage collection).
.ie n .IP "delete @objects_or_ids" 4
.el .IP "delete \f(CW@objects_or_ids\fR" 4
.IX Item "delete @objects_or_ids"
Deletes the specified objects from the store.
.Sp
Note that this can cause lookup errors if the object you are deleting is
referred to by another object, because that link will be broken.
.ie n .IP "set_root @objects" 4
.el .IP "set_root \f(CW@objects\fR" 4
.IX Item "set_root @objects"
.PD 0
.ie n .IP "unset_root @objects" 4
.el .IP "unset_root \f(CW@objects\fR" 4
.IX Item "unset_root @objects"
.PD
Modify the \f(CW\*(C`root\*(C'\fR flag on the associated entries.
.Sp
\&\f(CW\*(C`update\*(C'\fR must be called for the change to take effect.
.ie n .IP "txn_do $code, %args" 4
.el .IP "txn_do \f(CW$code\fR, \f(CW%args\fR" 4
.IX Item "txn_do $code, %args"
.PD 0
.ie n .IP "txn_do %args" 4
.el .IP "txn_do \f(CW%args\fR" 4
.IX Item "txn_do %args"
.PD
Executes \f(CW$code\fR within the scope of a transaction.
.Sp
This requires that the backend supports transactions
(KiokuDB::Backend::Role::TXN).
.Sp
Transactions may be nested.
.Sp
If the \f(CW\*(C`scope\*(C'\fR argument is true an implicit call to \f(CW\*(C`new_scope\*(C'\fR will be made,
keeping the scope for the duration of the transaction.
.IP "search \e%proto" 4
.IX Item "search %proto"
.PD 0
.ie n .IP "search @args" 4
.el .IP "search \f(CW@args\fR" 4
.IX Item "search @args"
.PD
Searching requires a backend that supports querying.
.Sp
The \f(CW\*(C`\e%proto\*(C'\fR form is currently unspecified but in the future should provide a
simple but consistent way of looking up objects by attributes.
.Sp
The second form is backend specific querying, for instance
Search::GIN::Query objects passed to KiokuDB::Backend::BDB::GIN or
the generic \s-1GIN\s0 backend wrapper KiokuDB::GIN.
.IP "root_set" 4
.IX Item "root_set"
Returns a Data::Stream::Bulk of all the root objects in the database.
.IP "all_objects" 4
.IX Item "all_objects"
Returns a Data::Stream::Bulk of all the objects in the database.
.ie n .IP "grep $filter" 4
.el .IP "grep \f(CW$filter\fR" 4
.IX Item "grep $filter"
Returns a Data::Stream::Bulk of the objects in \f(CW\*(C`root_set\*(C'\fR filtered by
\&\f(CW$filter\fR.
.ie n .IP "scan $callback" 4
.el .IP "scan \f(CW$callback\fR" 4
.IX Item "scan $callback"
Iterates the root set calling \f(CW$callback\fR for each object.
.IP "object_to_id" 4
.IX Item "object_to_id"
.PD 0
.IP "objects_to_ids" 4
.IX Item "objects_to_ids"
.IP "id_to_object" 4
.IX Item "id_to_object"
.IP "ids_to_objects" 4
.IX Item "ids_to_objects"
.PD
Delegates to KiokuDB::LiveObjects
.IP "directory" 4
.IX Item "directory"
Returns \f(CW$self\fR.
.Sp
This is used when setting up KiokuDB::Role::API delegation chains. Calling
\&\f(CW\*(C`directory\*(C'\fR on any level of delegator will always return the real KiokuDB
instance no matter how deep.
.SH "GLOBALS"
.IX Header "GLOBALS"
.ie n .IP "$SERIAL_IDS" 4
.el .IP "\f(CW$SERIAL_IDS\fR" 4
.IX Item "$SERIAL_IDS"
If set at compile time, the default \s-1UUID\s0 generation role will use serial IDs,
instead of UUIDs.
.Sp
This is useful for testing, since the same IDs will be issued each run, but is
utterly broken in the face of concurrency.
.SH "INTERNAL ATTRIBUTES"
.IX Header "INTERNAL ATTRIBUTES"
These attributes are documented for completeness and should typically not be
needed.
.IP "collapser" 4
.IX Item "collapser"
KiokuDB::Collapser
.Sp
The collapser prepares objects for storage, by creating KiokDB::Entry
objects to pass to the backend.
.IP "linker" 4
.IX Item "linker"
KiokuDB::Linker
.Sp
The linker links entries into functioning instances, loading necessary
dependencies from the backend.
.IP "live_objects" 4
.IX Item "live_objects"
KiokuDB::LiveObjects
.Sp
The live object set keeps track of objects and entries for the linker and the
resolver.
.Sp
It also creates scope objects that help ensure objects don't garbage collect
too early (\*(L"new_scope\*(R" in KiokuDB::LiveObjects, KiokuDB::LiveObjects::Scope),
and transaction scope objects used by \f(CW\*(C`txn_do\*(C'\fR
(KiokuDB::LiveObjects::TXNScope).
.IP "typemap_resolver" 4
.IX Item "typemap_resolver"
An instance of KiokuDB::TypeMap::Resolver. Handles actual lookup and
compilation of typemap entries, using the user typemap.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "Prior Art on the \s-1CPAN\s0"
.IX Subsection "Prior Art on the CPAN"
.IP "Pixie" 4
.IX Item "Pixie"
.PD 0
.IP "DBM::Deep" 4
.IX Item "DBM::Deep"
.IP "\s-1OOPS\s0" 4
.IX Item "OOPS"
.IP "Tangram" 4
.IX Item "Tangram"
.IP "DBIx::Class" 4
.IX Item "DBIx::Class"
.PD
Polymorphic retrieval is possible with DBIx::Class::DynamicSubclass
.IP "Fey::ORM" 4
.IX Item "Fey::ORM"
.PD 0
.IP "MooseX::Storage" 4
.IX Item "MooseX::Storage"
.PD
.SH "VERSION CONTROL"
.IX Header "VERSION CONTROL"
KiokuDB is maintained using Git. Information about the repository is available
on <http://www.iinteractive.com/kiokudb/>
.SH "AUTHOR"
.IX Header "AUTHOR"
Yuval Kogman <nothingmuch@woobling.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&    Copyright (c) 2008, 2009 Yuval Kogman, Infinity Interactive. All
\&    rights reserved This program is free software; you can redistribute
\&    it and/or modify it under the same terms as Perl itself.
.Ve
